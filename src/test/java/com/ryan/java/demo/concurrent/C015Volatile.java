package com.ryan.java.demo.concurrent;

/**
 * Volatile: 容易改变的，不稳定的
 */
public class C015Volatile {

    /**
     *   告诉虚拟机，这个变量容易被多线程访问，修改
     *
     *   保证程序内的可见性, 有序性
     *      不会被缓存在寄存器或对其他处理器隐藏的地方
     *      对其操作不会被CPU进行重新排序
     *      读取值时，总会返回某个线程写入的最新的值
     *
     *   不保证原子性
     *      如++操作
     *
     *   不会加锁，不会导致线程的阻塞
     *   相对于synchronize是轻量级的操作
     *
     *   常用于标识状态
     *
     *   原子变量提供'读-改-写'的操作， 常被称作更优雅的volatile变量
     *
     *   如果仅仅volatile变量仅仅被一个线程写，其他线程都是读
     *      这是对该变量的读-改-写操作就是线程安全的
     *
     *   什么时候使用volatile变量：
     *      1. 写入变量的时候，不依赖变量当前的值
     *          不是 读-改-写类型的操作， 不是check-if-write的操作
     *      2. 或者确保只有单一的线程修改该变量
     *      3. 变量不需要其他状态变量参与不变约束
     *          修改变量时，不依赖其他变量的值？
     *
     *  使用memory barrier指令，刷新缓存
     *
     */

    volatile Integer foo = new Integer(123);

    /**
     * 在servre模式下，
     */
}
